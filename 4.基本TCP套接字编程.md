# 概述

本章编写完整的TCP客户、服务程序所需要的套接字函数，并编写程序。

## socket函数

first buzhou。。。调用socket函数来确定通讯协议的类型
``` cpp
#include <sys/socket.h>
int socket(int family, int type, int protocol);
//返回:成功为非负描述符，若出错则为-1
```
参数解析：famiy:代表协议族，type指明套接字类型，
         protocol设置为某个协议类型常值，或0，用来选择所选family和type组合的系统默认值

这里仅仅使用socket来获得一个套接字描述符，并给其绑定协议族和套接字类型，并没有指定本地协议地址和远程协议地址

## connect函数

TCP客户用connect来建立与TCP服务器的连接
``` cpp
#include <sys/socket.h>
int connect(int sockfd, const struct sockaddr* servaddr, socklen_t addrlen);
//返回：成功返回0，出错返回-1
```
参数解析：sockfd是由socket返回的套接字描述符，第二个，第三个参数分别是一个指向套接字地址结构的指针和该结构的大小

套接字地址结构必须含有服务器的IP地址和端口号，客户端调用connect不需要调用bind，因为内核会自动确定IP以及一个临时端口

TCP套接字在调用connect会进行三次握手过程，而且仅在建立连接成功的情况下或出错才会返回，出错返回有以下几种情况
1. TCP客户没有收到SYN分节的响应，返回ETIMEDOUT错误，举例来说，发送一个SYN，无响应6s会重发，再无响应24s重发，再无响应75s再发一次，仍未收到则返回错误
1. 若对客户的响应是RST（复位），则表示服务器在我们所访问的端口上并无进程等待与之连接，直接返回ECONNREFUSED错误
    RST是TCP发生错误时返回的一种TCP分节，三种产生RST的方式为：
    1. 目的端口SYN到达，但并没有进程正在等待，返回RST
    1. TCP想取消一个已有连接
    1. TCP接收到一个根本不存在的连接上的分节
1. 客户端发送的SYN在中间的路由上引发了“目的地不可达”ICMP错误，软错误，按第一种方式进行多次重发，如果仍未收到，则返回ICMP错误消息返回

## bind函数

bind函数把本地的协议地址赋予一个套接字。
``` cpp
#include <sys/socket.h>
int bind(int sockfd, const struct *myaddr, socklen_t addrlen);
```
参数解析：第一个参数，是用来进行绑定的文件描述符，第二个参数是一个指向特定协议地址结构的指针，第三个参数是地址结构的长度
#### INADDR_ANY是用来指定通配地址的常值，其值一般为0，告知内核自己选择IP地址，Ipv6使用in6addr_any来设置
bind经常返回EADDRINUSE错误，表示地址已使用

## listen函数

``` cpp
#include <sys/socket.h>
int listen(int sockfd, int backlog);
```
listen仅由TCP服务器进行调用
1. 当socket创建一个套接字时，他被假设为一个主动套接字，它是一个将调用connect发起连接的客户套接字。listen把一个未连接的套接字变为一个被动的套接字，指示内核应接收指向该套接字的连接请求。调用listen将套接字由CLOSE态转换为LISTEN状态。
1. 本函数的第二个参数用来指定队列最大个数
   1. 未完成连接队列，由某客户端发送SYN到服务器，但还未完成三次握手过程，套接字处于STN_RCVD状态
   1. 已完成连接队列，已完成三次握手，套接字处于ESTABLISHED状态
不同系统对这个参数有不同的解释，有加一，有加三等等

## accept函数

accept函数由TCP服务进行调用，用于从已完成队列中返回下一个已完成连接，如果已完成队列为空，则投入睡眠
``` cpp
#include < sys/socket.h>
int accept(int sockfd, struct sockaddr* cliaddr, socklen_t *addrlen);
```
参数cliaddr，addrlen用来返回已完成连接的客户端的协议地址addr_len是值-结果参数
如果accept成功则返回一个由内核自动生成的描述符，代表与所返回的客户的链接
accept第一个参数为监听字套接符，称它的返回值为已连接套接字描述符
一个服务器同城仅仅创建一个套接字描述符，在他的生命周期中一直存在，内核为每个新的连接创建一个套接字描述符（TCP三次握手已经完成），当服务器完成对应的操作，相应的已连接套接字旧会关闭。
如果对客户端协议地址不感兴趣则可以将后两个参数职位空指针。

## fork,exec函数

fock()函数，Unix中用来生成进程的唯一函数
``` cpp
#include<unistd.h>
pid_t fork(void);
```
该函数返回两次，第一次在父进程中返回子进程的进程ID号，第二次在子进程中返回0.


## 并发服务器

处理长时间的连接请求，并希望同时处理多个的情况下可以采用并发服务器，最简单的方式采用fork()来处理每一个客户
``` cpp
eg:
pid_t pid;
int listenfd,connfd;
listenfd = Socket();
Bind(listenfd, ...);
Listen(listenfd, LISTENQ);

for(;;){
    confd = Accept(listenfd, ...);
    if((pid = Fork()) == 0){
        Close(listenfd);
        doit(connfd);
        Close(connfd);
        exit(0)
    }
    Close(connfd);
}
```
这里子进程关闭监听套接字，父进程则继续等待并关闭已连接套接字。（这里需要格外注意一下，每个套接字描述符均有一个引用计数，只有当引用计数为0时才释放描述符，所以父进程进行close时不会断开连接）

## close函数

通常Unix使用close来进行套接字的关闭，并终止TCP连接。
``` cpp
#include <unistd.h>
int close(int sockfd);
```
close一个套接字默认行为是将其标记成以关闭，然后立即返回到调用进程，即该套接字不能再使用read，write操作

### 如果我们确实想关闭一个套接字（在其引用计数不为0的情况下）这里使用shutdown()函数即可实现
如果父进程（这里默认子进程结束后关闭描述符）对每个套接字均不进行close操作，最后会耗尽描述符的个数，更为重要的是，没有一个客户链接会被终止。

## getsockname，getpeername函数

这两个函数或者返回与某某个套接字关联的本地协议地址，或者返回与某个套接字关联的外地协议地址。
``` cpp
#include <sys/socket.h>
int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);
int getpeername(int sockfd, struct sockaddr *peeraddr, socklen *addrlen);
//二者成功均返回一，失败均返回0
```

## 小结

所有客户端和服务器端均从调用socket开始，大多数TCP服务器是并发的，为每个客户连接调用一个fork。
服务器：socket->bind->listen->accept->close(shotdown)
客户端: socket->connect->close(shutdown)