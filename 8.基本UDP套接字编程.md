# 8.1 概述

        在使用 TCP 编写的程序和 UDP 编写的程序之间存在本质的差别，这两种协议的传输层存在差别：UDP 是无连接不可靠的数据报协议，不同于 TCP 提供的面向连接的可靠字节流。相比 TCP 有些场合更加适合使用 UDP,例如 DNS，NFS，SNMP系统等等

        客户和服务器之间的数据传输可以使用  sendto，recvfrom 两个函数来进行通讯，其中，sendto 必须指定目的地址，同理 recvfrom 会一并收到客户端的协议地址，所以服务器可以正确的对客户端进行响应

        本章会介绍在 UDP 协议中使用 connect 的影响

# 8.2 recvfrom 和 sendto 函数

类似于标准的 read 和 write 函数，但是需要额外的三个参数
```cpp
#include <sys/socket.h>
ssize_t recvfrom(int sockfd, void *buff, size_t nbytes, 
                 int flags, struct sockaddr *from, socklen_t *addrlen);

ssize_t sendto(int sockfd, const void *buff, size_t nbytes, 
                 int flags, const struct sockaddr *to, socklen_t addrlen);
                 // 若成功均返回读或写的字节数，出错返回 -1
                 // 与标准 read，write 不同，可以返回 0 代表只读 0 字节
                 // 但是在 TCP 中 read 返回 0 代表对端关闭连接
```
参数解析：
- sockfd：描述符
- buff：指向读入或输出的缓冲区指针
- nbytes：读写字节数
- flags：后面进行讨论
- to/from：指向一个协议地址（例如 IP 地址和端口号）的套接字地址结构，大小由 addrlen 参数决定

### 注意：sendto 最后一个参数是一个值类型，而 recvfrom 是一个指针类型
### 如果 recvfrom 的地址指针是一个空指针，那么长度指针也必须是一个空指针，代表并不关心是哪里发来的数据

# 8.3 UDP 回射服务器程序：main 函数

```cpp
int main(int argc, char ** argv){
    int sockfd;
    struct sockaddr_in servaddr, chiladdr;
    // 创建 UDP 套接字指定 SOCK_DGRAM
    sockfd = Socket(AF_INET, SOCK_DGRAM, 0);

    bzero(&servaddr, sizeof(servaddr));
    aervaddr.sin_family = AF_INET;
    aervaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    aervaddr.sin_port = htons(SERV_PORT);
    // 绑定本机地址
    Bind(sockfd, (SA*)&servaddr, sizeof(servaddr));
    // 执行服务器回射逻辑
    dg_echo(sockfd, (SA*) &cliaddr, sizeof(cliaddr));
}
```
# 8.4 UDP 回射服务器程序：dg_echo 函数

```cpp
void
dg_echo(int sockfd, SA *pcliaddr, socklen_t clilen)
{
	int			n;
	socklen_t	len;
	char		mesg[MAXLINE];

	for ( ; ; ) {
		len = clilen;
        // 使用 recvfrom 读取下一个到达端口的数据报，在使用 sendto 发送回发送者
		n = Recvfrom(sockfd, mesg, MAXLINE, 0, pcliaddr, &len);

		Sendto(sockfd, mesg, n, 0, pcliaddr, len);
	}
}
```
- 这个函数永远不会终止，因为 UDP 是一个无连接的协议，没有像 TCP 中 EOF 之类的东西
- 该服务器是一个迭代服务器，并没有使用 fork，所以一个服务器进程就可以处理所有的客户。一般来说大多数 TCP 服务器是并发的，大多数 UDP 服务器是迭代的
- 每一个 UDP 套接字均有一个接收缓冲区，当进程调用 recvfrom 时，缓冲区下一个数据报以 FIFO 方式返回给进程。使用 SO_RCVBUF 可以修改接收缓冲区

        上面的两个函数，main 函数是协议相关的（创建 AF_INET 套接字，分配并初始化一个 Ipv4 套接字地址结构），dg_echo 是协议无关的，因为 dg_echo 并不查看传入的地址只进行使用。

# 8.5 UDP 回射客户程序：main 函数
UDP 客户端的 main 函数
```cpp
int main(int argc, char **argv)
{
	int					sockfd;
	struct sockaddr_in	servaddr;

	if (argc != 2)
		err_quit("usage: udpcli <IPaddress>");
    // 把服务器的 IP + port 填入一个地址结构，将该结构发送给 dg_cli，用来表示数据发送到哪里
	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_port = htons(SERV_PORT);
	Inet_pton(AF_INET, argv[1], &servaddr.sin_addr);
    // 创建一个 UDP 套接字，调用 dg_cli
	sockfd = Socket(AF_INET, SOCK_DGRAM, 0);

	dg_cli(stdin, sockfd, (SA *) &servaddr, sizeof(servaddr));

	exit(0);
}
```
# 8.6 UDP 回射客户程序：dg_cli 函数
```cpp
void dg_cli(FILE *fp, int sockfd, const SA *pservaddr, socklen_t servlen)
{
	int	n;
	char	sendline[MAXLINE], recvline[MAXLINE + 1];
    // 从标准输入接收数据
	while (Fgets(sendline, MAXLINE, fp) != NULL) {
        // 发送给服务器
		Sendto(sockfd, sendline, strle n(sendline), 0, pservaddr, servlen);
        // 从服务器获取回射的数据
		n = Recvfrom(sockfd, recvline, MAXLINE, 0, NULL, NULL);
        // 把数据的末尾置为 \0
		recvline[n] = 0;	/* null terminate */
        // 打印出来
		Fputs(recvline, stdout);
	}
}
```
- 我们的客户端并没有指定 port，对于 UDP 套接字，在进程首次调用 sendto 的时候会由内核默认选择一个临时端口。和 TCP 一样，客户可以显示的调用 bind，几乎不会这么使用
- dg_cli 也是协议无关的函数，客户的 main 函数是协议相关的，main 函数初始化一个某种协议类型的地址结构，并将其发送给 dg_cli

# 8.7 数据报的丢失

        这个 UDP 客户端和服务器不可靠，如果一个客户端的数据丢失，客户端将永远阻塞在 recvfrom 调用上，防止这种情况一般是给 recvfrom 设置一个超时  
        但是超时并不能很好的解决问题，我们不能判断超时原因是数据没有到达服务器，还是服务器的应答没有回到客户。

# 8.8 验证接收到的响应

        因为客户端发送的数据是随机端口的，所以我们收到的数据报可能是多个进程互相混乱。暂时的方法是记录发送时的 IP 和 port，这样接收到数据时，仅需要进行判断，相同的地址则保留，忽略任何其他数据报。

我们修改 servaddr.sin_port = htons(SERV_PORT) 转换为 servaddr.sin_port = htons(7）  
重写 dg_cli 函数以分配另一个套接字地址结构用来存放 recvfrom 返回的结构
```cpp
void dg_cli(FILE *fp, int sockfd, const SA *pservaddr, socklen_t servlen)
{
	int				n;
	char			sendline[MAXLINE], recvline[MAXLINE + 1];
	socklen_t		len;
	struct sockaddr	*preply_addr;
    // 分配一个地址结构
	preply_addr = Malloc(servlen);

	while (Fgets(sendline, MAXLINE, fp) != NULL) {

		Sendto(sockfd, sendline, strlen(sendline), 0, pservaddr, servlen);

		len = servlen;
		n = Recvfrom(sockfd, recvline, MAXLINE, 0, preply_addr, &len);
        // 判断目标地址和回来的数据报的发送地址是否一致，不一致的话就忽略
		if (len != servlen || memcmp(pservaddr, preply_addr, len) != 0) {
			printf("reply from %s (ignored)\n",
					Sock_ntop(preply_addr, len));
			continue;
		}

		recvline[n] = 0;	/* null terminate */
		Fputs(recvline, stdout);
	}
}
```
&emsp;&emsp;如果这个程序仅运行在一个只有单个 IP 地址的服务器上，工作正常。但是服务器是多个 IP 的话，可能返回时的地址和发送的目的地址不一样，但都是一个服务器
- 解决办法一：得到 recvfrom 返回的地址之后，使用 DNS 查找服务器主机的名字来验证主机的域名（而不是 IP 地址）
- 解决办法二：UDP 服务器个体每个 IP 地址创建一个套接字服务器，用 bind 进行捆绑。然后使用 select 进行等待，之后根据不同的 IP 地址，进行发送即可，这就保证了应答的源地址和请求的目的地址相同

# 8.9 服务器进程未运行

        在不启动服务器的情况下启动客户的话，因为是 UDP 所以并不能直到服务器的状态，所以当客户端发送一个数据报时，会阻塞在 recvfrom 处，有超时会等待超时  
        当客户主机发送 UDP 数据报之前，需要一次 ARP 请求和应答的交换。  
        如果服务器没有启动，ARP 请求会返回一个 客户端不可达 的 ICMP 报错，但是并不会返回给客户端进程  
        这种错误是 异步错误，该错误由 sendto 引起，但是 sendto 本身却成功返回。我们知道 UDP 输出操作成功返回仅仅表示接口输出队列中具有存放所形成 IP 数据包的空间。但是错误在一段时间后返回，这就是异步的原因  
### 一个基本规则：对于一个 UDP 套接字，它引发的异步错误并不返回给它，除非它已连接。  

# 8.10 UDP 程序例子小结

        客户需要给 sendto 指定服务器的 IP + port，由内核自动选择客户端的 IP + port，客户端也可以使用 bind 来指定它们。客户的临时端口是在第一次调用 sendto 时由内核指定的，并且不可以进行改变；但是客户端的IP 地址可以每次调用 sendto 时进行随机选择。如果客户端时多宿的，那么客户端可以在多个 IP 地址之间反复横跳  
        如果客户捆绑一个 IP 地址到其套接字上，但是内核决定外出数据报必须从另一个数据链路发出，这种情况下， IP 数据报将包含一个不同于外出链路 IP 地址的源 IP 地址。  
        TCP 服务器，可以很容易的获取 源 IP + port 和 目的 IP + port。并且保持不变。对于 UDP 要想获取需要使用 IP_RECVDSTADDR 套接字并调用 recvmsg 函数来进行获取  

来自客户的 IP 数据报|TCP 服务器|UDP 服务器
-|-|-
源 IP 地址|accept|recvfrom
源 port|accept|recvfrom
目的 IP 地址|getsockname|recvmsg
目的 port|getsockname|getsockname
### &emsp;&emsp;服务器可从到达的 IP 数据报中获取的信息

# 8.11 UDP 的 connect 函数