# 概述

上一章的问题在于TCP客户端同时处理两个套接字，标准输入和TCP套接字。在客户阻塞于fgets调用期间，服务器进程会被杀死。服务器TCP虽然正确的给客户TCP发送了一个FIN，但是客户进程既然阻塞于标准输入读入的过程，他将看不到这个EOF。这样的进程需要一种预先告知内核的能力，使得内核一旦发现进程指定的一个或多个I/O条件接续，就通知进程，这被称为IO复用
IO服用的典型使用场合
1. 当客户处理多个描述符（通常是交互式输入和网络套接字），必须使用IO复用。这是我们上一章强调的
1. 一个客户同时处理多个套接字是可能的，但较为少见。可以使用select等方式来进行处理
1. 如果一个TCP服务器既要处理监听套接字，又要处理已连接套接字。一般要使用IO复用
1. 如果一个服务器既要处理TCP又要处理UDP，一般就要使用IO复用
1. 如果一个服务器要处理多个服务或者多个协议，一般要使用IO复用

## I/O模型

Unix下可用的I/O模型有五种

1. 阻塞式IO；
1. 非阻塞式IO；
1. IO复用（select和poll）；
1. 信号驱动式IO（SIGIO）；
1. 异步IO（POSIX的aio_系列函数）；

一个输入操作通常包括两个不同的阶段：
1. 等待数据准备好
1. 从内核向进程复制数据

#### 阻塞式I/O模型

在阻塞式IO模型中，所有套接字都是阻塞的，在该函数开始调用以及返回的时间对内。

#### 非阻塞式IO模型

进程把一个套接字设置成非阻塞是在通知内核：当请求的IO操作非要把本进程投入睡眠中才可完成时，不要把进程投入睡眠，而是返回一个错误

#### IO复用模型

有IO复用了，我们就可以调用select或poll，阻塞在这两个系统调用的某一个上，而不是阻塞在真正的IO系统调用上，使用了IO复用，阻塞于select的调用，等待数据报套接字变为可读。当select返回套接字可读这一条件时，我们调用recvfrom把所有数据报复制到应用进程缓冲区。

对于单个的描述符来说，Io复用甚至效果还不如阻塞IO，但它在多描述符的等待上会更有优势。

#### 信号驱动式IO模型

我们可以使用信号，让内核在描述符就绪时发送SIGIO信号通知我们。
这样我们就不会阻塞在数据的等待是，只会阻塞在复制数据的过程上。

#### 异步IO模型

告知内核某个操作，，并让内核在整个操作完成后进行通知即可，信号驱动式IO告诉我们可以进行一个IO操作，而异步IO告诉我们IO操作已经结束

#### 各种IO模型比较

前四种模型主要区别在第一阶段，第二阶段均相同：在数据从内核复制到调用者的缓冲区期间，进程阻塞于recvfrom调用，相反，异步IO模型在这两个阶段都要处理，从而不同于其余的模型

#### 同步IO和异步IO的对比

同步IO导致请求进程阻塞，直到IO操作完成
异步IO不导致请求阻塞

#### 同步与异步，阻塞与非阻塞

同步与异步：同步与异步是针对应用程序与内核的交互而言的。同步过程中进程触发IO操作并等待或者轮询的去查看IO操作是否完成。异步过程中进程触发IO操作以后，直接返回，做自己的事情，IO交给内核来处理，完成后内核通知进程IO完成，这里是针对第二个阶段的区分

阻塞与非阻塞：应用进程请求I/O操作时，如果数据未准备好，如果请求立即返回就是非阻塞，不立即返回就是阻塞。简单说就是做一件事如果不能立即获得返回，需要等待，就是阻塞，否则就可以理解为非阻塞。这里主要为第一个阶段的区分

虽然吧同步异步，阻塞非阻塞放在一起，但二者无必然联系

## select函数

该函数允许进程指示内核等待多个事件中的任何一个发生，并只有在一个或多个事件发生或经历一段指定的时间后才能唤醒它。

``` cpp
#include <sys/select.h>
#include <sys/time.h>

int select(int maxfdpl, fd_set* readset, fd_set* writeset, fd_set* exceptset, const struct timeval* timeout);
//返回:若有就绪描述符则返回其数目，若超时则为0，若出错则为-1
```
参数解析：
· timeout：告知内核等待所指定描述符中的任何一个就绪可花多长时间，其timeval结构如下
    struct timeval{
        long tv_sec;    //秒数
        long tv_usec;   //微秒数
    }
    这个参数有以下用法：
    1. 永远等待下去：仅在有一个描述符转备好IO时才返回，此时应置位空指针
    2. 等待一个固定的时间：在有一个描述符准备好IO时返回，但是不能超过该参数所指向的timeval结构中指定的秒数和微秒数
    3. 根本不等待：检查描述符之后立即返回，称为轮询（polling），该指针需要指向一个值为0的结构
· 中间的三个参数告诉内核我们指定在该描述符上的操作，读，写，异常条件的判断
    目前的异常条件只有两个：
    1. 某个套接字的带外数据的到达
    2. 某个已置位分组模式的伪终端存在可从其主端读取的控制状态信息
    要想给这三个参数指定描述符集，select使用的是一个整数数组，其中每一位对应一个描述符。

*使用select时一定要注意对最大描述符加一

#### 描述符就绪条件(UNP.p130)

满足以下四个条件之一，一个套接字准备好读
1. 该套接字接收缓冲区中的数据字节数大于等于套接字接收缓冲区低水位标记的当前大小。对这样的套接字执行读操作不会阻塞并返回一个大于0的值（也就是返回准备好读入的数据）。我们可以使用SO_RCLOWAT套接字选项设置套接字的低水位标记。对于TCP，UDP来说，默认为1.
1. 该链接的读半部关闭（也就是接受了FIN的TCP连接）。对于这样的操作读操作不会阻塞并返回0（EOF）。
1. 该套接字是一个监听套接字，并且已完成的连接数不为0.对于这样的套接字accept通常不会阻塞
1. 其上有一个套接字错误待处理，对于这样的套接字的读操作不阻塞并返回-1（返回一个错误），同时设置error为确切的错误操作

满足以下四个条件之一，一个套接字准备好写
1. 该套接字发送缓冲区中的可用空间大于等于套接字发送缓冲区低水位标记的当前大小，并且或者该套接字已经连接，或者该套接字不需要连接。如果我们把这样的套接字设置为非阻塞的，写操作不会阻塞一个正值。我们可以使用SO_SNDLOWAT套接字选项设置套接字的低水位标记。对于TCP，UDP来说，默认为2048.
1. 该连接的写半部关闭。对这样的套接字的写操作将产生SIGPIPE信号。
1. 使用非阻塞式connect的套接字以建立连接，或者connect已经以失败告终
1. 其上有一个套接字错误待处理，对于这样的套接字的写操作不阻塞并返回-1（返回一个错误），同时设置error为确切的错误操作

如果一个套接字存在外带数据或者仍处于带外标记，那么它有异常条件待处理

* 注意：如果某个套接字上发生错误时，它将由select标记为既可读又可写

总结表：
条件 | 可读吗？ | 可写吗？ | 异常吗？
-|-|-|-
有数据可读 | √ | | 
关闭连接的读一半 | √ | | 
给监听套接口转备好新链接 | √ | |
有可用于写的空间 | | √ | |
关闭连接的写一半 | | √ | |
待处理错误 | √ | √| |
TCP带外数据 | | | √ |

#### select的最大描述符

最开始select设置为进程中最大支持描述符个数。但随着系统的版本的迭代，单进程所支持的描述符个数已经大大增加，但是select并不能随意增加。

## str_cli函数

使用select来重新写str_cli函数，这样服务一旦终止，客户就可以马上得到通知

客户的套接字上三个条件处理如下
1. 如果对端TCP发送数据，那么该套接字变为可读，并且read返回一个大于0的值（即读入数据的字节数）
1.  